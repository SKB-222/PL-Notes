# Знакомство с языком Си

## Первая программа на Си

### Переменные в языке Си

**Определения:**

-  - нагрузка, указывающая основные свойства символа: тип и название
- Объявление - при объявлении несётся только информационная нагрузка. Если это переменная, то объявление предоставляет место, где она находится в памяти

Для обращение к глобальной переменной (вне блока) можно поставить двойное двоеточие перед переменной: `::var`

### Ключевые слова С89

Всего в языке C89 было 32 ключевых слова.

**Типы данных:**

- `char`
- `int`
- `long`
- `short`
- `float`
- `double`
- `void`

**Знаковость:**

- `signed`
- `unsigned`

**Время хранения:**

- `extern`
- `static`
- `auto`

**Квалификаторы:**

- `const`
- `volatile`

**Операторы языка:**

- `if`
- `else`
- `switch`
- `case`
- `default`
- `for`
- `while`
- `do`
- `break`
- `continue`

**Переходы:**

- `goto`
- `return`

**Составные типы данных:**

- `struct`
- `union`
- `enum`
- `typedef`

**Другое:**

- `sizeof`
- `register`

### Программы на языке C89

**Предупреждение:** В дальнейшем программы на Си в этом разделе будут написаны с использованием стандарта С89

Напишем программу для вывода строки в консоль:

```C
#include <stdio.h>
/*  
Директива препроцессора, обозначающая, что в это место
надо вставить текст из заголовочного файла stdio.h
*/

int main() // Точка входа
{
 printf("Hello, world!"); // Вывод в консоль
 return 0;
}
```

В программу можно передать параметры из командной строки. Параметры - строки в стиле C.
Первым параметром в программу всегда передаётся название запускаемой программы.
Напишем программу для вывода на экран переданных параметров в обратном порядке:

```C
#include <stdio.h> 

// argc - количество аргументов
// argv - сами аргументы, массив строк в стиле си

// "char **argv" можно записать как "char *argv[]"
int main(int argc, char **argv)
{
 while(argc > 1)
 {
  printf("%s\n", argv[--argc]);
 }
 return 0;
}
```

Для считывания значения из консоли используется функция scanf(). В неё передаётся форматная строка, по которой будет происходить считывание, и переменные, в которые будут записаны значения, введённые в консоли. Пример программы с этой функцией:

```C
#include <stdio.h> 


int main()
{
 int val;
 scanf("%d", &val); // здесь "%d" - форматная строки,
                    // которая считает одно число
 printf("val is: %d\n", val);
 return 0;
}
```

Эта программа считает и выведет в консоль считанное число. Что делать в случае, если было введено не число? В таком случае нужно написать обработчик ошибок ввода:

```C
#include <stdio.h> 

int main()
{
 int val;
 while(scanf("%d", &val) != 1) {
  // scanf вернёт число успешно считанных параметров
  printf("Error!\n");
 }
 // Дальше можно работать с переменной val
}
```

### Грамматика языка Cи

Опредения

- Токен - элементарный объект, который компилятор не разбивает на элементы компонентов
- Лексер - сканер, разбивающий входной поток на токены  

Токенами являются:

- Операторы
- Ключевые слова
- Константы
- Строковый литерал
- Знак пунктуации

Токенами препроцессора являются:

- Идентификаторы
- Непробельные символы
- Операторы
- Имя заголовочного файла
- Число препроцессора
- Символьная константа
- Строковый литерал
- Знак пунктуации

Приведём пример грамматики:

`Индентификатор` `::=` `Идентификатор` `ИЛИ` `Идентификатор`,
                       за которым следует `не цифра` ИЛИ `Идентификатор`,
                       за которым следует цифра, где `цифра` `::=` `0|1|2|3|4|5|6|7|8|9`,
                       а `не цифра ::= \_ |<маленькие латинские буквы>|<большие латинские буквы>`

Заметим, что индентификатор не может начинаться с цифры. Посмотреть как разбивается код на токены можно [тут](https://doublench.github.io/).

### Компиляция программы на C


Драйвер - программа, которая сделает приготовления, а потом запустит другую программу.


Для того, чтобы скомпилировать программу будет использоваться драйвер `gcc`. Ключи `gcc`:

- `-c` - выполнение только фазы трансляции. Возвращает объектный модуль.
- `-o` - устанавливает название выходного файла.
- `-std*` - устанавливает стандарт языка, по которому будет происходить трансляция. (Написать стандарт вместо звёздочки)
- `-Wall` - Показать все предупреждения.
- `-Werror` - все предупреждения становятся ошибками.
- `-pedantic` - предупреждает о плохом стиле программирования.

Раздельная компиляция - процесс трансляции всех изменённых файлов в объектные модули, которые потом связываются между собой в исполняемый файл.

Пусть у нас есть файлы: `main.c`, `parce.c` и `parse.h`. В `main.c` используется заголовочный файл `parse.h`. Сначала нужно странслировать файлы:

1. Трансляция `main.c` при помощи команды: ` gcc -c main.c -o main.o `
2. Трансляция `parse.c` при помощи команды: `gcc -c main.c -o parse.o`

После того, как были странслированны файлы для следующего этапа, Начинается этап компоновки. Во время этого этапа мы должны соединить два объектных файла следующей командой: `gcc main.o parse.o -o program -lm`

## Makefile

`Makefile` - стандартное имя файла систем управления сборками. Внутри него написаны команды, цели, переменные и т.д. Пример Makefile:

```bash
parse: main.o parse.o
 gcc main.o parse.o -o parse
main.o: main.c parse.h
 gcc -c main.c -o main.o
parse.o: parse.c
 gcc -c parse.c -o parse.o
```

Разберём построчно этот файл. В первой строке `parse` - название цели, которое совпадает с названием выходного файла. После двоеточия стоят файлы, которые нужны для выполнения этой цели. Во второй строчке стоят команды для выполнения цели. После того, как будут выполнены все команды из цели, цель завершится. В третьей строчке создаётся другая цель - `main.o`, которая совпадает с названием выходного файла. В зависимостях стоят файлы `main.c` и `parse.h`, но в командах используется только `main.c`, т.к. `main.c` подключает `parse.h` в свойм коде. В четвёртой строке написана команда для трансляции файла `main.c` в объектный файл `main.o`. В пятой строке создаётся ещё одна цель - `parse.o`. В зависимостях у неё всего один файл - `parse.c`. В последней строке написана команда для трансляции `parse.c` в `parse.o`.

Этот файл можно сделать более универсальным. Что если мы хотим использовать не `gcc`, а `clang`? В таком случае нам надо заменить везде в `makefile` `gcc` на `clang`. Чтобы быстро заменить драйвер, надо использовать переменные.

**Улучшение 1:**
В начале Makefile ставим  `CC=gcc`. В таком случае, если нужно изменить компилятор, будет достаточно изменить одну строчку в Makefile.

**Улучшение 2:**
Предположим, что мы хотим установить какие-то дополнительные флаги для трансляции и компоновки. Например: `-std=c89 -Wall -Werror -pedantic`. Для этого возьмём переменные `LDFLAGS` и `CFLAGS`. Нас интересует переменная `CFLAGS`, к ней мы добавим флаг трансляции `-c`.
`CFLAGS+=-c`

**Улучшение 3:**
В действиях цели можно использовать все файлы, указанные в зависимостях цели. Для этого можно поставить символы `$^`

**Улучшение 4:**
Можно подтянуть название цели для выходного файла. Для этого используются символы: `$@`

Улучшенный Makefile выглядит так:

```bash
CC=gcc
CFLAGS+=-c
parse: main.o parse.o
 $(CC) $(LDFLAGS) $^ -o $@
main.o: main.c parse.h
 $(CC) $(CFLAGS) main.c -o $@
parse.o: parse.c
 $(CC) $(CFLAGS) $^ -o parse.o  
```

## Особенности языка Си

### Массивы

**Массив** - это последовательность объектов того же типа, которые занимают непрерывную область памяти.

**Например:** мы хотим хранить 10 целых чисел. Хранить 10 переменных - неудобно, а использовать массив - удобно. При создании массива из 10 объектов типа `int`, в памяти выделится кусок объёмом 40 байт под этот массив.
Создание массива:

```C
int arr1[] = {1,2,3,4,5,6,7,8,9,0}; // создаётся массив из 10 элементов.
// Массиву автоматически известен его размер. Он не станет меньше или больше

int arr2[8]; // Здесь нет изначальных элементов для создания массива.
//Внутри этого массива будут случайные числа из памяти.

int arr3[8] = {}; // Массив из восьми элементов, заполненный нулями
int arr4[]; // Здесь будет ошибка
```

Обращение к массиву происходит при помощи квадратных скобок, внутри которых стоит индекс элемента, к которому надо обратиться. Индексы отсчитываются с нуля. Пример кода для работы с массивом:

```C
#include <stdio.h> 

int main()
{
 int i = 0;
 int arr[] = {1,2,3,4,5,6,7,8,9,10}; // Создание массива
 arr[4] = 13; // число 5 замениться на 13
 for(; i < 10; ++i)
  printf("%d\n", arr[i]); // Выведет обновлённый массив
 return 0;
}
```

### Строки в стиле Cи


Строка в стиле C представляют из себя массив char с кодом `\0` на конце


Пример кода для работы со строкой в стиле C. Напишем функцию для определения длины строки:

```C
#include <stdio.h> 

// Здесь слово "const" обозначает, что содержимое массива не будет меняться
int len(const char *s) 
{
 int ret = 0;
 while(*s++) ret++;
 return ret;
}

int main()
{
 char str[] = "Hello, World!";
 printf("%d\n", len(str)); // выведет длину строки, в данном случае - число 13
 return 0;
}
```

### Адресная арифметика

#### Работа с указателями

```C
int b = 9;    // b – переменная типа int длиной 4 байта 
int *ptr;     // ptr – указатель на объект типа int длиной 4 байта
ptr = &b;     // в ptr записывается адрес переменной b. & - взятие адреса.
ptr++;        // в ptr адрес увеличился на 4 байта - размер int. 
ptr--;        // в ptr адрес уменьшился на 4 байта - размер int. 
int a = *ptr; // в a теперь хранится значение ячейки памяти
              // куда указывает указатель, т.е. на b = 9
b = 7;        // в a всё ещё хранится значение 9, но в b хранится теперь 7.
```

Имя массива является указателем на первый элемент. Т.е. эквивиалентны записи `int i = arr;` и `int i = arr[0];`

При помощи указателей можно обратиться к любому элементу в массиве. Например эквивиалентны следующие записи: `int b = *(arr + 2);` и `int b = arr[2];`

Преобразование типов может быть явным и неявным. Явное преобразование типов - преобразование, вызванное разработчиком. Например:

```C
double b = 42.6;
int a = (int)b; // Здесь b преобразовалось в int и отсеклась дробная часть
```

В этом примере в скобках перед переменной написан тип, в который надо преобразовать переменную b. Приведём пример неявного преобразования типов, в котором нет круглых скобок.

```C
double b = 36.6;
int a = b; // Здесь b преобразовалось в int и отсеклась дробная часть
```

## Классовые типы

> Перечисления - это набор именованных целочисленных констант, определяющий все допустимые значения, которые может принимать переменная

Создадим простое перечисление дней недели:

```C
enum day {
 mon,
 tue,
 wed,
 thur,
 fri,
 sat,
 sun
};
```

Применим это перечисление:

```C
void fun(enum day d)
{
 if(d == mon) {
  // делать что-то, если понедельник
 }
}
```

Объединения - тип данных, который располагает все свои элементы в одном участке памяти. Размер участка памяти равен размеру большего элемента

Создадим объединение из двух полей:

```C
union binfet {
 float fet;
 int bin;
};
```

Теперь два поля fet и bin делят один участок памяти. Если мы меняем bin, то меняется и fet. Поставим значение -0.0f для полей:

```C
binfet value;
value.bin = 0x80000000; // выставили старший бит в единицу
if(value.fet == -0.0f) {/* минус в условии обозначает старший бит  */}
```

> Структуры - тип данных, который состоит из других компонентов. При этом в отличие от массива эти компоненты могут представлять различные типы данных.

Создадим структуру:

```C
struct Student {
 char Name[256];
 double GPA;
 int group;
};
```

Обращение к полям структуры:

```C
struct student st; // создание структуры
st.GPA = 9.0; // изменение поля
```

Структуры также поддерживают настройку ширины поля в битах. Пример:

```C
struct bits {
 char b7: 1; // Поле шириной в 1 бит
 char b6: 1; // Поле шириной в 1 бит
 char b5: 1; // Поле шириной в 1 бит
 char b4: 1; // Поле шириной в 1 бит
 char b3: 1; // Поле шириной в 1 бит
 char b2: 1; // Поле шириной в 1 бит
 char b1: 1; // Поле шириной в 1 бит
 char b0: 1; // Поле шириной в 1 бит
};

union byte {
 char value;
 struct bits bit;
}

/* Какой-то код */

union byte b;
b.value = 7;
if(b.bit.b0 == 1) {/* Код, если число чётное */}
```

### Указатель на функцию

Пусть дана функция:

```C
int MyFun(int a) {printf("%d",a);}
```

Можно взять указатель от этой функции и записать в переменную таким образом:

```C
int main()
{
 int(*funPtr)(int) = NULL;
 // В строчке выше:
 // первый int - тип возвращаемого значения
 // funPtr - название указателя на функцию (имя переменной);
 // второй (int) - какие параметры надо передать в функцию
 /* ... */
 funPtr = MyFun; // Имя функции - указатель на её начало
 funPtr(13); // вызов MyFun с параметром 13. Будет выведено 13
}
```

## Работа с потоками данных

В C есть функции для работы с данными из потока. Например:

```C
int fgetc(FILE *stream);
int fprintf(FILE *stream, const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
```

В этих функциях первым параметром передаётся структура файлового потока FILE.

Стандартные потоки имеют свои дескрипторы и файловые имена:

0. Поток ввода. stdin
1. Поток вывода. stdout
2. Поток ошибок. stderr

Пример работы с стандартными потоками и файловыми потоками:

```C
#include <stdio.h> 

int main()
{
 char buf[55];
 int s;
 fwrite("Hello, world!\n", 1, 14, stdout);
 s = fread(buf, 1, 54, stdin);
 if(s > 0)
 {
  buf[s] = '\n';
  fwrite(buf,1,s,stdout);
 }
 FILE* f = fopen("f.txt", "w");
 if(f != NULL)
 {
  fwrite(buf, 1, 55, f);
  fclose(f);
 }
 return 0;
}
```
