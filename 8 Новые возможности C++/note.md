# Новые возможности C++

Ниже приведён список новых возможностей (возможно полезные):

1. `__cplusplus` - макрос;
2. `auto` - автоматический вывод типа переменной;
3. `range based for` - `for` по диапазону;
4. Семантика перемещения;
5. `constexpr` - гарантированное константное выражение, т.е. что-то, что известно на момент компиляции. `constexpr` выполняется на моменте компиляции. При его использовании компиляция происходит дольше, но зато `runtime` быстрее;
6. `decltype` - получение доступа к типу переменной;
7. Cписки инициализации;
8. Делегирование конструктора копирования;
9. `static assert`;
10. `long long` (64 bit);
11. `nullptr`;
12. Функции с переменным числом параметров (были и в `C`, но здесь изменились из-за шаблонов и пачки параметров/свёртки);
13. `Rvalue`;
14. Сырая строка - строка, которая ведёт себя как строка, если дать ей значение. Нужна для регулярок;
15. Задание пользовательских литералов;
16. `noexcept` - в функциях с таким ключевым словом не надо писать throw. Она заведомо работает верно. Компилятор просто не выбросит исключение в функции с этим суффиксом;
17. Потоки;
18. Умные указатели;
19. Слова `functional`, `any`;
20. `chrono` (на самообучении);
21. Атомарные операции;
22. Концепции.
(Ну и так далее)

## Лямбда-функции

Лямбда-функция - безымянная функция. пример Лямбда-функции:

```cpp
[]() { std::cout << "Hello" << std::endl; }
```

Универсальная ссылка - Ссылка, которая может быть или lvalue ссылкой или rvalue ссылкой. обозначается при помощи \verb|&&|

Пример:

```cpp
void func(A &&a) // Параметр - всегда универсальная ссылка
{
 A b;
 func(b); // lvalue
 func(std::move(b)); // rvalue
 // std::move - подменяет объект на пустоту. Возвращает rvalue ссылку
 // std::forward - если объект может быть rvalue-ссылкой, то его достанут, иначе он останется lvalue
}
```

## Модули

Модули в C++ были придуманы для отдаления языка от препроцессора. Они являются заменой header'ов в C++20. ключевые слова: \verb|export, module, import|. Пример файла с модулем:

```cpp
export module NumberCruncher;
import logger;

#define CRUNCH_FACTOR 3.14

namespace numbers {

 float applyCrunchFactor(float number) {
  return number * CRUNCH_FACTOR;
 }
 
 export float crunch(float number) {
  auto crunched = applyCrunchFactor(number);
  logger::info("Crunched {} with result of {}", number, crunched);
  return crunched;
 }
 
}
```

Код, который импортирует модуль:

```cpp
import NumberCruncher; 

int main() {
    auto value = numbers::crunch(42);
}
```

## Диапазоны/Ranges

Библиотека ranges в C++ нужна, чтобы не передавать итераторы в уже написанные алогритмы. Например:

```cpp
...
std::vector vec = {1,3,2,7};
std::ranges::sort(vec);
...
```

Также существует такая вещь, как views. работают похожим образом как pipe в Linux. Пример:
`auto temp = vec|std::views::filter`(функция);

## Концепции

Механизм концепций был создан для установки ограничений на шаблоны. Пример использования позже. Сначала рассмотрим квалификаторы:

### Спецификаторы

Квалификаторы

- `const` - переменная не изменяется
- `volatile` - переменная изменяется неявно (atomic - его замена)
- `consteval` - функция должна быть ПРИНУДИТЕЛЬНО вычислена на этапе компиляции, в то время, как constexpr постарается вычислить значение функции на этапе компиляции, но если не получится, то вычислит во время выполнения программы.

Пример использования `constexpr` и `consteval` в C++17:

```cpp
if constexpr(...) {...} // Сгенерирует одну ветку: либо if, либо else, в зависимости от выполнения условия
if consteval(...) {...} // Сработает также, как и constexpr, но гарантированно на этапе компиляции
```

Пример constexpr C++11:

```cpp
#include <iostream>

constexpr int i = 10;
int arr[i];
constexpr int fun(int a, int b)
{
 return a*b;
}

int main()
{
 fun(1,2); // Compile-time
 int n;
 std::cin >> n;
 fun(n,3); // Runtime
 return 0;
}
```

Пример consteval C++20:

```cpp
#include <iostream>

consteval int fun(int a, int b)
{
 return a*b;
}

int main()
{
 fun(1,2); // OK
 int n;
 std::cin >> n;
 fun(n,3); // Error
 return 0;
}
```

Также есть спецификатор `constinit`, который гарантированно пропихнёт значение на этапе компиляции, но переменную с этим спецификатором можно поменять только в `runtime`. Пример constinit в C++20:

```cpp
#include <iostream>

constexpr int fun(int a, int b) { return a * b; }
constinit int val = fun(1,2); // OK
constinit in err = val; // error

int main()
{
 val = 42; // OK
 return 0;
}
```

## SFINAE

Substitution Failure Is Not An Error (SFINAE): при определении перегрузок функции ошибочные инстанциации шаблонов не вызывают ошибку компиляции, а отбрасываются из списка кандидатов на наиболее подходящую перегрузку. Пример:

```cpp
struct bar 
{
 typedef double internal_type;
};
template <typename T>
typename T::internal_type fun(T t) // Здесь строчка "typename T::internal_type" проверяет, что шаблон содержит тип internal_type
{
 return 0;
}
int main()
{
 fun(bar()); // OK
 fun(0); // Error
 return 0;
}
```

## Свойства типов (C++11)

При помощи механизма концепций можно проверять:

1. Итераторы;
2. Свойства (`signed`, `unsigned`);
3. Допустимые операции (`is_copybale`);
4. Отношение между типами (`is_same_as`);
5. Вспомогательные функции и метки;

Пример, в котором шаблон `T` доступен, если `T` - арифметический тип:

```cpp
template<class T> typename enable_if<is_arithmetic<T>::value, T>::type fun(T t)
{
 return t;
}
```

Чтобы сократить количество букв в написании проверки, можно использовать суффиксы: для `::type` - `_t`, а для `::value` - `_v`.

Например: `enable_if<...>::type <=> enable_if_t<...>`

`decltype` нужен, чтобы "на лету" получить имя типа. `declval` - позволяет вызвать метод, не создавая объект.
Пример `decltype`:

```cpp
template<typename T, typename U>
auto fun(T a, U b) -> decltype(a+b) // Такая конструкция называется хвостовой вывод типа
{
 return 2*a+4.5*b;
}
```

Пример declval: `decltype(declval<T>()::size())`

## Vaniadic templates - Шаблоны с переменным числом параметров

Пишется так:

```cpp
template<typename T, typename... Types> // Здесь троеточие называется пачкой параметров (Parameter pack)
void fun(T t, Types... args)
{
 /*...*/
}
```

Чтобы узнать сколько параметров передано, используется функция sizof...(args). Пример:

```cpp
template<typename T, typename... Types>
void print(T t, Types... args)
{
 if constexpr (sizeof...(args)==0) {}
 else
 {
  cout << t << endl;
  print(args...);
 }
}
```

Пример со свёрткой:

```cpp
template<typename... Types>
void print(Types... args)
{
 (cout << ... << args) << endl;
}
```

Ещё один пример, когда все значения просуммированны:

```cpp
int sum(Types... args)
{
 return (... + args);
}
```

## Designated initializers

Агрегат - массив либо классовый тип, который не имеет:

1. Закрытых защищённых нестатичечких полей;
2. Пользовательских или унаследованных конструкторов;
3. Виртуальных, закрытых функций;
4. Все его базовые классы (если имеются) - тоже агрегаты;

Если простыми словами, то агрегат - структура из C.

Пример:

```cpp
struct Point {
 double x = {0};
 double y = {0};
}
...
Point p {.x=3, .y={4}} // Можно пропускать значения, если у поля есть default, главное, чтобы параметры шли по порядку
```

## `char8_t`

`char8_t` - это тип, который используется для представления единиц кода `UTF-8`

Для этого типа также существует разновидность `char16_t` и `char32_t` для представления единиц кода `UTF-16` и `UTF-32`. `u8string` - строка, состоящая из `char8_t`.
Примеры использования:

```cpp
using namespace std::literals;

// ...

char8_t c = u8'@';
// ...
auto s = u8"Hello"s; // здесь s будет типа string, т.к. мы казали постфикс "s"
std::string s2 = u8"Hello"; // Ошибка при c++20
```

## Потоки

Пример кода с дополнительным потоком:

```cpp
// ...
int main()
{
 std::thread t([](){ std::cout << "Thread"; });
 // ...
 t.join();
}
```

Ещё один пример кода:

```cpp
void f1() { std::cout << "."; }
void f2() { std::cout << "-"; }
void main()
{
 std::thread t1(f1);
 std::thread t2(f2);
 for(...)
  std::cout << "!";
 t1.join();
 t2.join();
}
```

В случае выше поток будет голодать.

Starving (голодание) - поток готов к выполнению, но его не вызывают. Промежуток времени между состоянием готов к выполнению и использованием потока

Для синхронизации потоков используются следующие механизмы:

- `std::mutex` - примитив синхронизации потоков. Запрещает менять данные в потоке.
- `std::stop_source` - общая точка доступа к потокам через токены.
- `std::stop_token` - токен, который выдаётся потокам для работы `stop_source`.
- `std::callbac`k - ф-я, которая будет вызвана при попытки остановки потока.
- Контескт потока - Область памяти, к которой поток имеет доступ.
- Атомарные операции - Переменные, которые передаются по шине памяти за один цикл

Решение голодания: расстановка приоритета. `Mutex` связан с блокировкой (`lock`) следующим образом: `lock` привязывается к `mutex` и в деструктуре вызывается `unlock`.

**Определения:**

- Защёлка - Примитив синхронизации. Защёлка управляет несколькими потоками. Нельзя использовать, когда защёлкивается
- Барьер - защёлка, но его можно использовать, когда защёлкивается
- Реентрабельность - Возможность функции войти в себя снова. **restrict** - параметр внутри функции не меняется

## Сопрограммы

Сопрограмма - Код, который работает параллельно с основным потоком. Функция, у которой может быть несколько точек входа. Их контекст хранится в куче.

Для того, чтобы функция была сопрограммой с точки зрения компилятора, нужно добавить одно из трёх ключевых слов:

1. `co_await` - блокировка до получения результата
2. `co_yield` - блокировка до следущего вызова функции
3. `co_return` - возвращение финального значения функции.

На тип возвращаемого значения из сопрограммы накладываются 3 ограничения:

1. Возвращаемое значение - классовый тип `std::coroutine_handle`;
2. Корректное уничтожение (должен быть деструктор);
3. Должен быть `promise_type`, который параметризует `coroutine_handle` со следующими методами:
   - `initial_suspend` - метод, у которого пустое тело. Если он есть, то программа будет ждать какого-то события;
   - `final_suspend` - По завершению, программа будет чего-то ждать;
   - `get_return_object` - позволяет получить объект возвращаемого типа;
   - Если используется оператор `co_return` или `co_yield` без указания типа, то возвращается `void`.
4. `return_value` с перегрузкой возвращаемого значения;
5. `yield_value`;
6. `await_transform` - нужен для `co_await`, чтобы над значением, переданным в `co_await` можно было совершать какие-то действия.
